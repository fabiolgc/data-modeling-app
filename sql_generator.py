"""
Gerador de SQL DDL para Databricks
"""

from models import DataModel, Table, Field, Relationship, RelationshipType
from typing import List


def generate_field_definition(field: Field) -> str:
    """Gera a definição SQL de um campo"""
    parts = [f"  {field.name} {field.data_type}"]
    
    # Nullable
    if not field.is_nullable and not field.is_primary_key:
        parts.append("NOT NULL")
    
    # Comentário
    if field.description:
        # Escapa aspas simples na descrição
        desc = field.description.replace("'", "''")
        parts.append(f"COMMENT '{desc}'")
    
    return " ".join(parts)


def generate_table_ddl(table: Table, catalog: str = "main", schema: str = "default") -> str:
    """Gera o DDL de uma tabela"""
    lines = []
    
    # CREATE TABLE
    full_table_name = f"{catalog}.{schema}.{table.name}"
    lines.append(f"CREATE TABLE IF NOT EXISTS {full_table_name} (")
    
    # Campos
    field_defs = []
    for field in table.fields:
        field_defs.append(generate_field_definition(field))
    
    # Primary Key constraint
    pk_fields = [f.name for f in table.fields if f.is_primary_key]
    if pk_fields:
        pk_constraint = f"  CONSTRAINT pk_{table.name} PRIMARY KEY ({', '.join(pk_fields)})"
        field_defs.append(pk_constraint)
    
    lines.append(",\n".join(field_defs))
    lines.append(")")
    
    # USING DELTA
    lines.append("USING DELTA")
    
    # Table comment
    if table.description:
        desc = table.description.replace("'", "''")
        lines.append(f"COMMENT '{desc}'")
    
    # TBLPROPERTIES com tags
    tag_fields = [(f.name, f.tags) for f in table.fields if f.tags]
    if tag_fields:
        lines.append("TBLPROPERTIES (")
        props = []
        for field_name, tags in tag_fields:
            tags_str = ','.join(tags)
            props.append(f"  '{field_name}.tags' = '{tags_str}'")
        lines.append(",\n".join(props))
        lines.append(")")
    
    return "\n".join(lines) + ";\n"


def generate_foreign_key_constraints(
    model: DataModel, 
    catalog: str = "main", 
    schema: str = "default"
) -> List[str]:
    """Gera as constraints de chave estrangeira baseadas nos relacionamentos"""
    constraints = []
    
    for rel in model.relationships:
        from_table = model.tables.get(rel.from_table)
        to_table = model.tables.get(rel.to_table)
        
        if not from_table or not to_table:
            continue
        
        # Encontra chaves primárias e estrangeiras
        from_fk = [f for f in from_table.fields if f.is_foreign_key]
        to_pk = [f for f in to_table.fields if f.is_primary_key]
        
        if from_fk and to_pk:
            from_field = from_fk[0].name
            to_field = to_pk[0].name
            
            constraint_name = f"fk_{rel.from_table}_{rel.to_table}"
            from_full_name = f"{catalog}.{schema}.{rel.from_table}"
            to_full_name = f"{catalog}.{schema}.{rel.to_table}"
            
            # Nota: Databricks suporta constraints mas nem todas são enforced
            constraint = f"""-- Foreign Key Constraint (informational)
-- ALTER TABLE {from_full_name}
-- ADD CONSTRAINT {constraint_name}
-- FOREIGN KEY ({from_field}) REFERENCES {to_full_name}({to_field});
"""
            constraints.append(constraint)
    
    return constraints


def generate_ddl(
    model: DataModel, 
    catalog: str = "main", 
    schema: str = "default",
    include_comments: bool = True
) -> str:
    """Gera o DDL completo do modelo de dados"""
    ddl_parts = []
    
    # Header
    if include_comments:
        ddl_parts.append("-- ================================================")
        ddl_parts.append("-- Data Model DDL for Databricks")
        ddl_parts.append("-- Generated by Data Modeling App")
        ddl_parts.append("-- ================================================\n")
    
    # Criar catalog e schema se necessário
    if include_comments:
        ddl_parts.append(f"-- Create catalog and schema")
    ddl_parts.append(f"CREATE CATALOG IF NOT EXISTS {catalog};")
    ddl_parts.append(f"CREATE SCHEMA IF NOT EXISTS {catalog}.{schema};\n")
    
    # Usar o schema
    ddl_parts.append(f"USE {catalog}.{schema};\n")
    
    # Gerar DDL para cada tabela
    if include_comments and model.tables:
        ddl_parts.append("-- ================================================")
        ddl_parts.append("-- Tables")
        ddl_parts.append("-- ================================================\n")
    
    for table_name, table in model.tables.items():
        if include_comments:
            ddl_parts.append(f"-- Table: {table_name}")
            if table.description:
                ddl_parts.append(f"-- {table.description}")
        
        ddl_parts.append(generate_table_ddl(table, catalog, schema))
    
    # Gerar constraints de chave estrangeira
    if model.relationships:
        if include_comments:
            ddl_parts.append("\n-- ================================================")
            ddl_parts.append("-- Foreign Key Constraints")
            ddl_parts.append("-- ================================================\n")
        
        fk_constraints = generate_foreign_key_constraints(model, catalog, schema)
        ddl_parts.extend(fk_constraints)
    
    # Informações sobre relacionamentos
    if include_comments and model.relationships:
        ddl_parts.append("\n-- ================================================")
        ddl_parts.append("-- Relationships Summary")
        ddl_parts.append("-- ================================================")
        for rel in model.relationships:
            ddl_parts.append(
                f"-- {rel.from_table} {rel.relationship_type.value} {rel.to_table}"
            )
    
    return "\n".join(ddl_parts)


def generate_alter_table_ddl(table: Table, catalog: str = "main", schema: str = "default") -> str:
    """Gera comandos ALTER TABLE para modificar uma tabela existente"""
    lines = []
    full_table_name = f"{catalog}.{schema}.{table.name}"
    
    lines.append(f"-- Alter table {table.name}")
    
    for field in table.fields:
        # ADD COLUMN
        field_def = generate_field_definition(field).strip()
        lines.append(f"ALTER TABLE {full_table_name} ADD COLUMN IF NOT EXISTS {field_def};")
    
    return "\n".join(lines)

